A graphics library is a collection of abstractions,
which allow developers to make use the capabilities of graphics hardware,
such as graphics cards.
Many such libraries exist,
ranging from low level \acs{api} that only offer rendering capabilities,
to higher level ones that provide additional functionality.
To provide one example of a high level library,
% TODO: cite
BGFX is a ``cross-platform, graphics API agnostic rendering library''.
Graphics API agnostic means that it targets many low level graphics \acs{api}.

Most of these libraries and \acs{api} are implemented for many programming languages,
and when they aren't,
bindings are usually available.
In the case of Common Lisp however,
OpenGL is the only API available with a somewhat actively maintained library.
Some others exist,
and those will be touched upon in section \ref{SEC:SOTA}.

\subsection{OpenGL}

OpenGL is a cross-language,
cross-platform graphics API for rendering vector graphics.
By the nature of the specification,
it has support for 2D and 3D graphics,
but the library itself doesn't distinguish those.

In order to function,
an OpenGL context needs to be instantiated.
This context then maintains state,
which will instruct the graphics hardware how to operate.
To render a mesh for example,
the context needs to be manipulated into the corresponding state,
and then a rendering command can be executed.
Working directly with this API is very cumbersome,
especially as the scale of a project grows.
The listings \ref{COD:GLINTRO_1},
\ref{COD:GLINTRO_2},
\ref{COD:GLINTRO_3},
\ref{COD:GLINTRO_4},
\ref{COD:GLINTRO_5} and \ref{COD:GLINTRO_6}
showcase this with the most simple example program possible,
rendering a single triangle.
The program has been broken down with explanations for each part.
This shows why an engine with appropriate abstractions is an absolute necessity.

% Global variables
\LispCode[COD:GLINTRO_1]{Basic OpenGL example \textemdash Global variables for 3D mesh and shader code}{These variables contain our mesh information, and our vertex shader code. They are not included fully here because their length would be substantial.}{gl-basic-example.lisp}{1}{7}{1}

% glfwInit and glfwCreateWindow
\LispCode[COD:GLINTRO_2]{Basic OpenGL example \textemdash Initialize OpenGL and create objects}{The GLFW functions take care of interacting with the OS to create a new window, a new OpenGL context, and link them. The rest of the variables are the minimum OpenGL objects we need to render anything to the screen.}{gl-basic-example.lisp}{9}{27}{9}

% Shader compilation and linking
\LispCode[COD:GLINTRO_3]{Basic OpenGL example \textemdash Shader compilation and linking}{These OpenGL functions load shader source into memory and compile the shaders so that the GPU can execute them. Then the shaders get linked together in a shader program that the GPU will use as a rendering pipeline.}{gl-basic-example.lisp}{29}{39}{29}

% Setting up vao
\LispCode[COD:GLINTRO_4]{Basic OpenGL example \textemdash Vertex array spec}{Here we load all the mesh data into OpenGL buffers and we specify its structure. The functions on lines 53 and 54 take care of mapping the different vertex attributes onto the relevant shader inputs.}{gl-basic-example.lisp}{41}{54}{41}

% Render Loop
\LispCode[COD:GLINTRO_5]{Basic OpenGL example \textemdash Render loop}{The actual rendering code. Of these lines, the only part that actually instructs OpenGL to render is the function call on line 65. The other functions only take care of getting the OpenGL context in the proper state. The final two lines instruct that the OS to draw the rendered framebuffer the window.}{gl-basic-example.lisp}{56}{74}{56}

% Cleanup
\LispCode[COD:GLINTRO_6]{Basic OpenGL example \textemdash Cleanup}{These final lines free up the OpenGL objects that were created at the beginning of the program.}{gl-basic-example.lisp}{76}{79}{76}
