One of the goals of this project is the ability to generate procedural meshesh.
A very important tool to that end is 3D smooth noise.
When we talk about noise,
we are talking about any \textit{n} dimentional function that will output a random value.
In the case of smooth noise,
the desired effect is for those values to change gradually when the input parameters also change gradually.
One such example can be seen in figure \ref{SBFIG:PERLIN}.
In order to generate higher detail and a more organic look,
lower frequency, scaled up noise (or viceversa) can be blended on top,
like in figure \ref{SBFIG:PERLIN_FRACTAL}.

\begin{figure}[Perlin noise example]{FIG:PERLIN}{2D slice through 3D perlin noise.}
  \subfigure[SBFIG:PERLIN]{2D slice through 3D perlin noise}{\image{0.4\textwidth}{}{perlin}}
  \subfigure[SBFIG:PERLIN_FRACT]{Layered perlin noise}{\image{0.4\textwidth}{}{perlin_fractal}}
\end{figure}

\subsection{Perlin noise}

The noise function that has been chosen for this project is Perlin noise.
It was developed by Ken Perlin in 1983 because he was frustrated with the ``machine-like'' look of imaged generated by computers at the time.
Algorithm \ref{ALG:PERLIN} explains how it works.
It has been adapted from the original to reduce duplicate operations.

\begin{algorithmN}[ALG:PERLIN]{Perlin Noise}{Perlin noise algorithm. It differs from the original in that a context object is used to keep track of previous calculations. By including these in the noise implementation, the caller only has to keep track of a seed to get repeatable values.}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \SetKwFunction{Hash}{Hash}
  \emph{These values make up our context}\;
  \Input{A map of generated gradients $G(x,y,z,s)$}
  \Input{A map of generated values $V(x,y,z,s)$}
  \emph{These values are our sample point and seed}\;
  \Input{A point $P$}
  \Input{A seed $S$}
  \Output{A value between -1 and 1}
  \If{$\exists V(P, S)$}{
    \Return{$V(P, S)$}
  }
  \If{$\not \exists G(P, S)$}{
    $G(P, S) \leftarrow$ \Hash{$P_x, P_y, P_z, S$}
  }
\end{algorithmN}
